import { __hubSpotComponentRegistry } from '../../../__synced__/remoteComponents.synced';
import { isRenderedElementNode, isRenderedFragmentNode } from '../type-utils';
import { ComponentNotFoundError, FindInvalidComponentError, InvalidComponentsError, } from './errors';
/**
 * Checks if the element matches the matcher.
 *
 * @param element The element to check.
 * @param matcher An optional matcher to filter the elements.
 * @returns `true` if the element matches the matcher, `false` otherwise.
 */
const checkElementMatches = (element, matcher) => {
    // If no matcher is provided, the element matches
    if (!matcher) {
        return true;
    }
    // Check if the matcher is a predicate function
    if (typeof matcher === 'function') {
        return matcher(element);
    }
    // Check if all the props in the matcher match the props in the element
    return Object.keys(matcher).every((key) => element.props[key] === matcher[key]);
};
const addMatchToFindResult = (findResult, match, options) => {
    if (options.findFirstOnly) {
        findResult.match = match;
    }
    else {
        findResult.allMatches.push(match);
    }
};
/**
 * Recursive helper for finding elements in the rendered tree.
 * NOTE: The input `findResult` is mutated in place.
 *
 * @param parentNode The parent node to search in.
 * @param options The options for the find operation.
 * @param findResult The find result to mutate.
 */
const findInternalHelper = (parentNode, options, findResult) => {
    const { children } = parentNode;
    const { targetComponent, matcher, findFirstOnly, findDirectChildrenOnly } = options;
    const targetComponentName = __hubSpotComponentRegistry.getComponentName(targetComponent);
    for (const child of children) {
        if (!isRenderedElementNode(child)) {
            // Skip over non-element child nodes (just text nodes)
            continue;
        }
        if (child.name === targetComponentName &&
            checkElementMatches(child, matcher)) {
            // We found a match, so add it to the find result
            addMatchToFindResult(findResult, child, options);
            if (findFirstOnly) {
                return;
            }
        }
        // We only search in nested children and fragment props if we're not only looking for children
        if (!findDirectChildrenOnly) {
            // Search for the component in the fragment props
            const { props } = child;
            const fragmentProps = __hubSpotComponentRegistry.getComponentFragmentPropNames(child.name);
            for (const fragmentPropName of fragmentProps) {
                const maybeFragment = props[fragmentPropName];
                // NOTE: As part of the conversion process of converting remote nodes to rendered nodes, we
                //       create a RenderedFragmentNode for each fragment prop and put that into the props object.
                if (isRenderedFragmentNode(maybeFragment)) {
                    findInternalHelper(maybeFragment, options, findResult);
                    if (findFirstOnly && findResult.match) {
                        return;
                    }
                }
            }
            // Search for the component in the child
            findInternalHelper(child, options, findResult);
            if (findFirstOnly && findResult.match) {
                return;
            }
        }
    }
    return;
};
/**
 * Internal utility that centralizes finding elements in the rendered tree (including error handling).
 *
 * @param parentNode The parent node to search in.
 * @param options The options for the find operation.
 * @returns The find result.
 */
const findInternal = (parentNode, options) => {
    const { document } = parentNode;
    const { targetComponent, findMethodName, shouldThrowErrorIfNotFound } = options;
    const targetComponentName = __hubSpotComponentRegistry.getComponentName(targetComponent);
    if (!targetComponentName) {
        throw new FindInvalidComponentError({
            findMethodName,
        });
    }
    // We always validate the document before running the find operation since the document may
    // have been updated asynchronously in the background.
    if (document.hasInvalidComponentNames()) {
        throw new InvalidComponentsError(document.rootNode);
    }
    // Initialize the find result that will be mutated in place
    const findResult = {
        match: null,
        allMatches: [],
    };
    // Run the internal find helper to recursively search the rendered tree
    findInternalHelper(parentNode, options, findResult);
    if (findResult.match === null && shouldThrowErrorIfNotFound) {
        throw new ComponentNotFoundError({
            findMethodName: options.findMethodName,
            parentNode,
            componentName: targetComponentName,
        });
    }
    return findResult;
};
/**
 * Finds the first descendant element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first element node that matches the given component or `null` if no match is found.
 */
export const maybeFind = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: false,
        findMethodName: 'maybeFind',
        shouldThrowErrorIfNotFound: false,
    });
    return match;
};
/**
 * Finds the first descendant element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first element node that matches the given component.
 */
export const find = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: false,
        findMethodName: 'find',
        shouldThrowErrorIfNotFound: true,
    });
    return match;
};
/**
 * Finds all descendant element nodes that match the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns An array of element nodes that match the given component.
 */
export const findAll = (parentNode, targetComponent, matcher) => {
    const { allMatches } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: false,
        findDirectChildrenOnly: false,
        findMethodName: 'findAll',
        shouldThrowErrorIfNotFound: false,
    });
    return allMatches;
};
/**
 * Finds the first direct child element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first child element node that matches the given component.
 */
export const findChild = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: true,
        findMethodName: 'findChild',
        shouldThrowErrorIfNotFound: true,
    });
    return match;
};
/**
 * Finds the first direct child element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first child element node that matches the given component.
 */
export const maybeFindChild = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: true,
        findMethodName: 'maybeFindChild',
        shouldThrowErrorIfNotFound: false,
    });
    return match;
};
/**
 * Finds all direct child element nodes that match the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns An array of child element nodes that match the given component.
 */
export const findAllChildren = (parentNode, targetComponent, matcher) => {
    const { allMatches } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: false,
        findDirectChildrenOnly: true,
        findMethodName: 'findAllChildren',
        shouldThrowErrorIfNotFound: false,
    });
    return allMatches;
};
