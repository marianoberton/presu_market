import { useEffect, useReducer, useMemo, useRef, useCallback } from 'react';
import { fetchAssociations, DEFAULT_PAGE_SIZE, calculatePaginationFlags, } from '../utils/fetchAssociations';
function createInitialState(pageSize) {
    return {
        results: [],
        error: null,
        isLoading: true,
        currentPage: 1,
        pageSize,
        hasMore: false,
        currentOffset: undefined,
        nextOffset: undefined,
        offsetHistory: [],
    };
}
function associationsReducer(state, action) {
    switch (action.type) {
        case 'FETCH_START':
            return {
                ...state,
                isLoading: true,
                error: null,
            };
        case 'FETCH_SUCCESS':
            return {
                ...state,
                isLoading: false,
                results: action.payload.results,
                hasMore: action.payload.hasMore,
                currentOffset: action.payload.currentOffset,
                nextOffset: action.payload.nextOffset,
                error: null,
            };
        case 'FETCH_ERROR':
            return {
                ...state,
                isLoading: false,
                error: action.payload,
                results: [],
                hasMore: false,
                currentOffset: undefined,
                nextOffset: undefined,
            };
        case 'NEXT_PAGE':
            return {
                ...state,
                currentPage: state.currentPage + 1,
                offsetHistory: state.currentOffset !== undefined
                    ? [...state.offsetHistory, state.currentOffset]
                    : state.offsetHistory,
                currentOffset: state.nextOffset,
                nextOffset: undefined,
            };
        case 'PREVIOUS_PAGE': {
            const newPage = Math.max(1, state.currentPage - 1);
            const newHistory = [...state.offsetHistory];
            const previousOffset = newHistory.pop();
            return {
                ...state,
                currentPage: newPage,
                offsetHistory: newHistory,
                currentOffset: previousOffset,
                nextOffset: undefined,
            };
        }
        case 'RESET':
            return {
                ...state,
                currentPage: 1,
                results: [],
                hasMore: false,
                error: null,
                currentOffset: undefined,
                nextOffset: undefined,
                offsetHistory: [],
            };
        default:
            return state;
    }
}
const DEFAULT_OPTIONS = {};
/**
 * A hook to fetch and manage associations between CRM objects with pagination support.
 */
export function useAssociations(config, options = DEFAULT_OPTIONS) {
    const pageSize = config?.pageLength ?? DEFAULT_PAGE_SIZE;
    const [state, dispatch] = useReducer(associationsReducer, useMemo(() => createInitialState(pageSize), [pageSize]));
    /**
     * HOOK OPTIMIZATION:
     *
     * Create stable references for config and options to prevent unnecessary re-renders and API calls.
     * Then, external developers can pass inline objects without worrying about memoization
     * We handle the deep equality comparison ourselves, and return the same object reference when content is equivalent.
     */
    const lastConfigRef = useRef();
    const lastConfigKeyRef = useRef();
    const lastOptionsRef = useRef();
    const lastOptionsKeyRef = useRef();
    const stableConfig = useMemo(() => {
        const configKey = JSON.stringify(config);
        if (configKey === lastConfigKeyRef.current) {
            return lastConfigRef.current;
        }
        lastConfigKeyRef.current = configKey;
        lastConfigRef.current = config;
        return config;
    }, [config]);
    const stableOptions = useMemo(() => {
        const optionsKey = JSON.stringify(options);
        if (optionsKey === lastOptionsKeyRef.current) {
            return lastOptionsRef.current;
        }
        lastOptionsKeyRef.current = optionsKey;
        lastOptionsRef.current = options;
        return options;
    }, [options]);
    // Pagination actions
    const nextPage = useCallback(() => {
        const paginationFlags = calculatePaginationFlags(state.currentPage, state.hasMore);
        if (paginationFlags.hasNextPage) {
            dispatch({ type: 'NEXT_PAGE' });
        }
    }, [state.currentPage, state.hasMore]);
    const previousPage = useCallback(() => {
        const paginationFlags = calculatePaginationFlags(state.currentPage, state.hasMore);
        if (paginationFlags.hasPreviousPage) {
            dispatch({ type: 'PREVIOUS_PAGE' });
        }
    }, [state.currentPage, state.hasMore]);
    const reset = useCallback(() => {
        dispatch({ type: 'RESET' });
    }, []);
    // Fetch the associations
    useEffect(() => {
        let cancelled = false;
        let cleanup = null;
        const fetchData = async () => {
            try {
                dispatch({ type: 'FETCH_START' });
                // Build request using current offset token
                const request = {
                    toObjectType: stableConfig?.toObjectType,
                    properties: stableConfig?.properties,
                    pageLength: pageSize,
                    offset: state.currentOffset,
                };
                const result = await fetchAssociations(request, {
                    propertiesToFormat: stableOptions.propertiesToFormat,
                    formattingOptions: stableOptions.formattingOptions,
                });
                if (!cancelled) {
                    dispatch({
                        type: 'FETCH_SUCCESS',
                        payload: {
                            results: result.data.results,
                            hasMore: result.data.hasMore,
                            nextOffset: result.data.nextOffset,
                            currentOffset: state.currentOffset,
                        },
                    });
                    cleanup = result.cleanup;
                }
            }
            catch (err) {
                if (!cancelled) {
                    const errorData = err instanceof Error
                        ? err
                        : new Error('Failed to fetch associations');
                    dispatch({ type: 'FETCH_ERROR', payload: errorData });
                }
            }
        };
        fetchData();
        return () => {
            cancelled = true;
            // Call cleanup function to release resources
            if (cleanup) {
                cleanup();
            }
        };
    }, [
        stableConfig,
        stableOptions,
        state.currentPage,
        state.currentOffset,
        pageSize,
    ]);
    // Calculate pagination flags
    const paginationFlags = calculatePaginationFlags(state.currentPage, state.hasMore);
    return {
        results: state.results,
        error: state.error,
        isLoading: state.isLoading,
        pagination: {
            hasNextPage: paginationFlags.hasNextPage,
            hasPreviousPage: paginationFlags.hasPreviousPage,
            currentPage: state.currentPage,
            pageSize: state.pageSize,
            nextPage,
            previousPage,
            reset,
        },
    };
}
