import { useEffect, useReducer, useMemo, useRef } from 'react';
import { fetchCrmProperties, } from '../utils/fetchCrmProperties';
const initialState = {
    properties: {},
    error: null,
    isLoading: true,
};
function crmPropertiesReducer(state, action) {
    switch (action.type) {
        case 'FETCH_START':
            return {
                ...state,
                isLoading: true,
                error: null,
            };
        case 'FETCH_SUCCESS':
            return {
                ...state,
                isLoading: false,
                properties: action.payload,
                error: null,
            };
        case 'FETCH_ERROR':
            return {
                ...state,
                isLoading: false,
                error: action.payload,
                properties: {},
            };
        default:
            return state;
    }
}
const DEFAULT_OPTIONS = {};
/**
 * A hook for using and managing CRM properties.
 */
export function useCrmProperties(propertyNames, options = DEFAULT_OPTIONS) {
    const [state, dispatch] = useReducer(crmPropertiesReducer, initialState);
    /**
     * HOOK OPTIMIZATION:
     *
     * Create stable references for propertyNames and options to prevent unnecessary re-renders and API calls.
     * Then, external developers can pass inline arrays/objects without worrying about memoization
     * We handle the deep equality comparison ourselves, and return the same object reference when content is equivalent.
     */
    const lastPropertyNamesRef = useRef();
    const lastPropertyNamesKeyRef = useRef();
    const lastOptionsRef = useRef();
    const lastOptionsKeyRef = useRef();
    const stablePropertyNames = useMemo(() => {
        if (!Array.isArray(propertyNames)) {
            return propertyNames;
        }
        const sortedNames = [...propertyNames].sort();
        const propertyNamesKey = JSON.stringify(sortedNames);
        if (propertyNamesKey === lastPropertyNamesKeyRef.current) {
            return lastPropertyNamesRef.current;
        }
        lastPropertyNamesKeyRef.current = propertyNamesKey;
        lastPropertyNamesRef.current = sortedNames;
        return sortedNames;
    }, [propertyNames]);
    const stableOptions = useMemo(() => {
        const optionsKey = JSON.stringify(options);
        if (optionsKey === lastOptionsKeyRef.current) {
            return lastOptionsRef.current;
        }
        lastOptionsKeyRef.current = optionsKey;
        lastOptionsRef.current = options;
        return options;
    }, [options]);
    // Fetch the properties
    useEffect(() => {
        let cancelled = false;
        let cleanup = null;
        const fetchData = async () => {
            try {
                dispatch({ type: 'FETCH_START' });
                const result = await fetchCrmProperties(stablePropertyNames, (data) => {
                    if (!cancelled) {
                        dispatch({ type: 'FETCH_SUCCESS', payload: data });
                    }
                }, stableOptions);
                if (!cancelled) {
                    dispatch({ type: 'FETCH_SUCCESS', payload: result.data });
                    cleanup = result.cleanup;
                }
            }
            catch (err) {
                if (!cancelled) {
                    const errorData = err instanceof Error
                        ? err
                        : new Error('Failed to fetch CRM properties');
                    dispatch({ type: 'FETCH_ERROR', payload: errorData });
                }
            }
        };
        fetchData();
        return () => {
            cancelled = true;
            // Call cleanup function to release RPC resources
            if (cleanup) {
                cleanup();
            }
        };
    }, [stablePropertyNames, stableOptions]);
    return state;
}
